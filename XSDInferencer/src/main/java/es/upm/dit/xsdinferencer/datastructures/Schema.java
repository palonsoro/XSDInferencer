package es.upm.dit.xsdinferencer.datastructures;

import static com.google.common.base.Preconditions.checkArgument;
import static es.upm.dit.xsdinferencer.XSDInferenceConfiguration.XML_NAMESPACE_URI;
import static es.upm.dit.xsdinferencer.XSDInferenceConfiguration.XSD_NAMESPACE_PREFIX;
import static es.upm.dit.xsdinferencer.XSDInferenceConfiguration.XSD_NAMESPACE_URI;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeMap;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Sets;
import com.google.common.collect.Table;

import es.upm.dit.xsdinferencer.XSDInferenceConfiguration;
import es.upm.dit.xsdinferencer.statistics.Statistics;

/**
 * Main data structure which holds all the information of the current inference process, 
 * including found nodes and types information and statistics. All the other data strucutures 
 * are used, directly or indirectly, by this. There must be only ONE Schema object per inference 
 * process, although its information can lead to many XSDs to be generated by a generator.
 * @author Pablo Alonso Rodriguez (Center for Open Middleware)
 */
public class Schema {
		
	/**
	 * Keys are namespace URIs and values are sets of known prefixes which have been once mapped to a given URI 
	 */
	private NavigableMap<String,SortedSet<String>> namespaceToKnownPrefixesMapping;
		
	/**
	 * It contains all the known elements of the schema in this way:
	 * <ul>
	 * <li>Rows are Namespaces</li>
	 * <li>Columns are keys of the form (enclosingComplexType<i>typeNamesAncestorsSeparator</i>)?elementName 
	 * (enclosingComplexType is avoided when the element is a root element).</li>
	 * <li>Values are the SchemaElement objects associated with the elements</li>
	 * </ul>
	 * This table must be maintained in order to be able to generate global elements or elementGroups when needed.
	 */
	private Table<String,String,SchemaElement> elements;
	/**
	 * It contains all the known attributes of the schema in this way:
	 * <ul>
	 * <li>Rows are Namespaces</li>
	 * <li>Columns are keys of the form enclosingComplexType<i>typeNamesAncestorsSeparator</i>attributeName</li>
	 * <li>Values are the SchemaAttribute objects associated with the elements</li>
	 * </ul>
	 * This table must be maintained in order to be able to generate attributeGroups when needed.
	 */
	private Table<String,String,SchemaAttribute> attributes;
	
	/**
	 * Maps a complex type name to the ComplexType that represents it.
	 */
	private Map<String,ComplexType> complexTypes;
	
	/**
	 * Maps a simple type name to the SimpleType that represents it.
	 */
	private Map<String,SimpleType> simpleTypes;
	
	/**
	 * Statistics of this complex type
	 */
	private Statistics statistics;
	
	/**
	 * Map that stores the already solved URI-to-prefix namespace mappings. 
	 * It must be rebuilt if the known URI-to-prefix mappings change.
	 */
	private NavigableMap<String,String> uniqueNamespaceURIToPrefix=null;
	
	/**
	 * Default constructor
	 */
	public Schema(int inputDocumentsCount){
		namespaceToKnownPrefixesMapping = new TreeMap<String,SortedSet<String>>();
		elements = HashBasedTable.create();
		attributes = HashBasedTable.create();
		complexTypes = new LinkedHashMap<String,ComplexType>();
		simpleTypes = new LinkedHashMap<String,SimpleType>();
		statistics = new Statistics(inputDocumentsCount);
	}
	
	/**
	 * Copy constructor.
	 * @param otherSchema The schema to copy.
	 */
	public Schema(Schema otherSchema){
		namespaceToKnownPrefixesMapping = new TreeMap<String,SortedSet<String>>(otherSchema.namespaceToKnownPrefixesMapping);
		elements = HashBasedTable.create(otherSchema.elements);
		attributes = HashBasedTable.create(otherSchema.attributes);
		complexTypes = new LinkedHashMap<String,ComplexType>(otherSchema.complexTypes);
		simpleTypes = new LinkedHashMap<String,SimpleType>(otherSchema.simpleTypes);
		statistics = new Statistics(statistics);
	}
	
	/**
	 * Custom fields constructor
	 * @param namespaceToKnownPrefixesMapping mappings between namespaces and their known prefixes. 
	 * @param elements table of elements
	 * @param attributes table of attributes
	 * @param complexTypes map of complex types
	 * @param simpleTypes map of simple types
	 * @param statistics the statistics
	 * @throws NullPointerException if any field is null
	 */
	public Schema(NavigableMap<String, SortedSet<String>> namespaceToKnownPrefixesMapping,
			Table<String, String, SchemaElement> elements,
			Table<String, String, SchemaAttribute> attributes,
			Map<String, ComplexType> complexTypes,
			Map<String, SimpleType> simpleTypes, Statistics statistics) {
		if(namespaceToKnownPrefixesMapping==null||elements==null||attributes==null||complexTypes==null||simpleTypes==null||statistics==null)
			throw new NullPointerException("No null argument is accepted");
		this.namespaceToKnownPrefixesMapping = namespaceToKnownPrefixesMapping;
		this.elements = elements;
		this.attributes = attributes;
		this.complexTypes = complexTypes;
		this.simpleTypes = simpleTypes;
		this.statistics = statistics;
	}

	/**
	 * @return the statistics
	 */
	public Statistics getStatistics() {
		return statistics;
	}

	/**
	 * This method returns the map that maps each namespace URI to its known namespaces. 
	 * As this map may be modified, the information about solved URI-to-prefix mapping 
	 * could become obsolete, so it is cleared, in order to force it to be rebuilt 
	 * the next time that it is requested. If no change is going to be made to this map, 
	 * {@link Schema#getNamespacesToPossiblePrefixMappingUnmodifiable()} should be used instead 
	 * of this method.
	 * @return the map that maps each namespace URI to its known namespaces
	 */
	public Map<String, SortedSet<String>> getNamespacesToPossiblePrefixMappingModifiable() {
		uniqueNamespaceURIToPrefix=null;
		return namespaceToKnownPrefixesMapping;
	}
	
	/**
	 * This method returns an immutable copy (as an {@link ImmutableMap}) of the map that 
	 * maps each namespace URI to its known namespaces. As that map cannot be modified, 
	 * it is not necessary to clear the information about
	 * @return an immutable copy of the map that maps each namespace URI to its known namespaces.
	 */
	public Map<String, SortedSet<String>> getNamespacesToPossiblePrefixMappingUnmodifiable() {
		Map<String, SortedSet<String>> result = new LinkedHashMap<>(namespaceToKnownPrefixesMapping.size());
		for(String uri: namespaceToKnownPrefixesMapping.keySet()){
			result.put(uri, ImmutableSortedSet.copyOf(namespaceToKnownPrefixesMapping.get(uri)));
		}
		return ImmutableMap.copyOf(result);
	}

	/**
	 * @return the table of elements of the schema
	 * @see Schema#elements
	 */
	public Table<String, String, SchemaElement> getElements() {
		return elements;
	}

	/**
	 * @return the table of attributes of the schema
	 * @see Schema#attributes
	 */
	public Table<String, String, SchemaAttribute> getAttributes() {
		return attributes;
	}

	/**
	 * @return the map of complex types
	 * @see Schema#complexTypes
	 */
	public Map<String, ComplexType> getComplexTypes() {
		return complexTypes;
	}

	/**
	 * @return the map of simple types
	 * @see Schema#simpleTypes
	 */
	public Map<String, SimpleType> getSimpleTypes() {
		return simpleTypes;
	}

	/**
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
//		final int prime = 31;
//		int result = 1;
//		result = prime * result
//				+ ((attributes == null) ? 0 : attributes.hashCode());
//		result = prime * result
//				+ ((complexTypes == null) ? 0 : complexTypes.hashCode());
//		result = prime * result
//				+ ((elements == null) ? 0 : elements.hashCode());
//		result = prime
//				* result
//				+ ((prefixNamespaceMapping == null) ? 0
//						: prefixNamespaceMapping.hashCode());
//		result = prime * result
//				+ ((simpleTypes == null) ? 0 : simpleTypes.hashCode());
//		result = prime * result
//				+ ((statistics == null) ? 0 : statistics.hashCode());
//		return result;
		return Objects.hash(attributes,complexTypes,elements,namespaceToKnownPrefixesMapping,simpleTypes);
	}

	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof Schema)) {
			return false;
		}
		Schema other = (Schema) obj;
		if (attributes == null) {
			if (other.attributes != null) {
				return false;
			}
		} else if (!attributes.equals(other.attributes)) {
			return false;
		}
		if (complexTypes == null) {
			if (other.complexTypes != null) {
				return false;
			}
		} else if (!complexTypes.equals(other.complexTypes)) {
			return false;
		}
		if (elements == null) {
			if (other.elements != null) {
				return false;
			}
		} else if (!elements.equals(other.elements)) {
			return false;
		}
		if (namespaceToKnownPrefixesMapping == null) {
			if (other.namespaceToKnownPrefixesMapping != null) {
				return false;
			}
		} else if (!namespaceToKnownPrefixesMapping.equals(other.namespaceToKnownPrefixesMapping)) {
			return false;
		}
		if (simpleTypes == null) {
			if (other.simpleTypes != null) {
				return false;
			}
		} else if (!simpleTypes.equals(other.simpleTypes)) {
			return false;
		}
//		if (statistics == null) {
//			if (other.statistics != null) {
//				return false;
//			}
//		} else if (!statistics.equals(other.statistics)) {
//			return false;
//		}
		return true;
	}
	
//	public boolean containsUnqualifiedElements(){
//		return namespaceToKnownPrefixesMapping.get("").contains("");
//	}

	/**
	 * It solves which namespace URI should be prefixed with which prefix. Empty namespace is always mapped 
	 * to non prefix and the XSD namespace is always mapped to the prefix defined by {@linkplain XSDInferenceConfiguration#XSD_NAMESPACE_PREFIX}
	 * @return a Map<String,String> between namespace URIs and prefixes such that there are not two or more namespaces mapped to the same prefix
	 */
	public NavigableMap<String,String> getSolvedNamespaceMappings(){
		if(uniqueNamespaceURIToPrefix!=null){
			return uniqueNamespaceURIToPrefix;
		}
		NavigableMap<String, String> results = solveMappings(namespaceToKnownPrefixesMapping);
		uniqueNamespaceURIToPrefix=results;
		return results;
	}

	/**
	 * Given the Map<String,SortedSet<String>> between namespace URIs and all their respectively known prefixes of the current Schema,
	 * it solves which prefix should correspond to which namespace.
	 * @return a Map<String,String> between the namespace URIs and the solved prefixes.
	 */
	protected NavigableMap<String, String> solveMappings() {
		return solveMappings(namespaceToKnownPrefixesMapping);
	}

	/**
	 * Given a Map<String,SortedSet<String>> between namespace URIs and all their respectively known prefixes, it 
	 * solves which prefix should correspond to which namespace.
	 * @param namespaceToKnownPrefixesMapping a Map<String,Set<String>> between namespace URIs and the Set<String> objects that contains their known prefixes
	 * @return a Map<String,String> between the namespace URIs and the solved prefixes.
	 */
	public static NavigableMap<String, String> solveMappings(NavigableMap<String, SortedSet<String>> namespaceToKnownPrefixesMappingInput) {
		NavigableMap<String,SortedSet<String>> namespaceToKnownPrefixesMapping = new TreeMap<>(namespaceToKnownPrefixesMappingInput);
		NavigableMap<String,String> results=new TreeMap<>();
		SortedSet<String> defaultNamespacePrefixes = namespaceToKnownPrefixesMapping.get("");
		if((defaultNamespacePrefixes!=null)&&(defaultNamespacePrefixes.contains("")))
			results.put("","");
		if(namespaceToKnownPrefixesMapping.containsKey(XSD_NAMESPACE_URI)){
			String xsdPrefix = XSD_NAMESPACE_PREFIX.replace(":", "");
			results.put(XSD_NAMESPACE_URI, xsdPrefix);
		}
		//It is mandatory that the namespace URI "http://www.w3.org/XML/1998/namespace" is 
		//bounded to the prefix xml (it is even not necessary to declare it).
		if(namespaceToKnownPrefixesMapping.containsKey(XML_NAMESPACE_URI)){
			String xmlPrefix = "xml";
			results.put(XML_NAMESPACE_URI, xmlPrefix);
		}
		for(String namespaceURI: namespaceToKnownPrefixesMapping.keySet()){
			SortedSet<String> knownPrefixes = namespaceToKnownPrefixesMapping.get(namespaceURI);
			checkArgument(!knownPrefixes.isEmpty(),"The set of known prefixes of the namespace '"+namespaceURI+"' is empty.");
			//Prefixes which have not been mapped yet
			Set<String> nonMappedPrefixes =results.values()!=null?Sets.difference(knownPrefixes, ImmutableSet.copyOf(results.values())):knownPrefixes;
			//Prefixes which have been mapped only to this namespace
			Set<String> uniquePrefixes = new LinkedHashSet<>(nonMappedPrefixes);
			if(results.containsKey(namespaceURI))
				continue;
			for(String namespaceURI2: namespaceToKnownPrefixesMapping.keySet()){
				if(namespaceURI.equals(namespaceURI2))
					continue;
				uniquePrefixes.removeAll(namespaceToKnownPrefixesMapping.get(namespaceURI2));
			}
			String prefix="";
			boolean needsCounter=true;
			if(!uniquePrefixes.isEmpty()){
				prefix=uniquePrefixes.iterator().next();
				needsCounter=false;
			}
			else if(!nonMappedPrefixes.isEmpty()){
				prefix=nonMappedPrefixes.iterator().next();
			}
			else {
				Iterator<String> knownPrefixesIterator = knownPrefixes.iterator();
				while(knownPrefixesIterator.hasNext()&&prefix.equals(""))
					prefix=knownPrefixesIterator.next();
			}
			if(prefix.equals("")&&(namespaceToKnownPrefixesMappingInput.containsKey(""))){
				prefix="unprefixed";
				needsCounter=true;
			}
			if(needsCounter){
				int i;
				for(i=1;results.values().contains(prefix+i);i++);
				prefix=prefix+i;
			}
			results.put(namespaceURI, prefix);
		}
		return results;
	}
	
	/**
	 * This method tries to guess the main namespace of this schema if no one is configured or 
	 * returns the configured one, if any. 
	 * That namespace will be the one which has more elements in the schema and is not skipped. 
	 * If more than one namespace has the greatest number of elements, then the one with most attributes 
	 * is chosen. If there also is more than one namespace in that situation, one of them is chosen.
	 * @param configuration the inference configuration
	 * @return a namespace URI of the main namespace
	 */
	public String guessMainNamespace(XSDInferenceConfiguration configuration){
		String configurationMainNamespace = configuration.getMainNamespace();
		if(configurationMainNamespace!=null)
			return configurationMainNamespace;
		String namespaceCandidate = null;
		int elementMaxCount = Integer.MIN_VALUE;
		int attributeMaxCount = Integer.MIN_VALUE;
		Table<String, String, SchemaElement> schemaElements = this.getElements();
		Table<String, String, SchemaAttribute> schemaAttributes = this.getAttributes();
		for(String namespace:schemaElements.rowKeySet()){
			Map<String, SchemaElement> elementsOfCurrentNamespace = schemaElements.row(namespace);
			Map<String, SchemaAttribute> attributesOfCurrentNamespace = schemaAttributes.row(namespace);
			if(elementsOfCurrentNamespace.keySet().size()>elementMaxCount||
					(elementsOfCurrentNamespace.keySet().size()==elementMaxCount&&attributesOfCurrentNamespace.keySet().size()>attributeMaxCount)){
				namespaceCandidate=namespace;
				elementMaxCount=elementsOfCurrentNamespace.keySet().size();
				attributeMaxCount=attributesOfCurrentNamespace.keySet().size();
			}
		}
		return namespaceCandidate;
	}
}